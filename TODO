Basic Resource (Modifying A Real Thing) Support

- Add `changes` API, distinguish between explicit user desired changes and
  "loaded values" that may or may not have changed / drifted
- Make API to change things: if_changed, if_create, if_change_desired (which is probably where try_change lands)
- Create the resource tree and resource :name object
- Add events and printing
- Add "recipe" (might be handled automatically by resource tree)
- Type specialization: tests, and merging of "attributes".  Probably best to wait until after resource tree is built.
- Prevent "attribute" from overwriting non-attribute methods (even on base classes
  or modules)
- Can we prevent people from screwing up and writing both "load" and "load_value"?
  Or at least tell them when they do it?  It can cause inconsistent results.

Nesting
- Add nested structs
- Add hashes
- Add sets
- Add indexed sets
- Add arrays

Specifics
- Provisioning: provisioning.machine, aws.sdk, aws.instance, docker.image, docker.container, docker.image
- Chef API: net.rest, chef.authentication, chef.server, formats.json, chef.node
- Local Mode: entry, file, directory, chef.repository, chef.ruby_format, chef.defaults
- Zero: net.http_server, chef.authentication, core.authorization
- Chef::Config
- Command Line tying it all together
- Server that serves resources

Future
- Race condition protection?  etcd-content id, by date, by checksum ...

...

- Think about race condition protection / content id / etc.



                        # NEXT 2: structs as changesets
      # Store "changes" as hash
      # "if_changed" in "update" method
      #
      # NEXT 3: nested struct changesets
      # Make override block work at class level, not just block level
      # Struct attributes modify the parent "changes" hash on update
      # StructAttribute
      # This should make defaults writeable as well; StructAttribute is created
      # *on top of* the default.
      # name(..., &override_block) - update idiom
      #
      # NEXT 4: lazy reality (GET+PUT)
      # "actual_value" instance method for struct and for attributes, called
      # instead of default
      # StructAttribute initializes "actual_value" to "parent_struct.actual_value.name"
      #
      # NEXT 5: primitive attributes
      # Symbol
      # String/Fixnum (non-modified types)
      #
      # NEXT 6: proper inheritance
      # Make inheritance bring over parent identity attributes
      # Make "attribute :x" specialize parent attribute :x if there is one
      # address(Address.open) create another layer of address vs. ref (value vs. ref)
      #
      # NEXT 6: events, logging
      #
      # NEXT 4: struct hierarchy
      # RecipeDSL
      # Crazytown::Chef.global_dsl
      #
      # NEXT 5: useful primitives
      # ruby_block
      # execute
      # file
      #
      # NEXT 6: hash
      #
      # NEXT 7: set
      #
      # NEXT 8: array
      #
      # NEXT 9: path, symbol
      #
      # TODO generic events; content/path; super validation; logfile output; super cool curses output; GUI output
      #
