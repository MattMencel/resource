module Crazytown
  #
  # Represents the desired state of a real resource.  While this is initially
  # the *actual* state (and getters will get the actual state), any values which
  # are modified in the Resource are reflected in the desired state.
  #
  # A Resource does *not* actually apply the changes: only Recipes do this.
  # When you make modifications to a Resource, the Resource calls `add_recipe`
  # and makes the changes to desired state and/or calls `add_recipe` on its
  # parent resource.
  #
  # When modifications are made to a Resource:
  # - The modifications MUST be available to statements in the current scope
  #   after the modification statement ends (note: they only need to be
  #   available via the resource interface itself)
  # - The modifications MUST be available to parent scopes after the current
  #   scope closes
  # - The modifications SHOULD NOT be available to parent scopes before the current scope or statement closes
  #   the modifications
  # - The modifications in a scope SHOULD be atomically handled together.
  #
  # Modifications to a thing in a parent scope must open a new resource in the
  # new scope, not just modify the old one.
  #
  module Resource
    def initialize(parent_resource)
      @parent_resource = parent_resource
    end

    #
    # The resource in which this resource was declared.  It *always* must
    # understand all recipes generated by resources underneath it.
    #
    # This is the resource cook(recipe) will be called on.
    #
    attr_reader :parent_resource

    #
    # When a child or other person has decided this resource should be updated,
    # it calls cook(recipe) with a recipe.  All resources are required
    # to respond to this; most find a way to either directly incorporate it, or
    # pass it to their parent by creating a new recipe with the new parent.
    #
    def cook(recipe)
      raise NotImplementedError, "add_recipe"
    end

    #
    # Shortened form of add_recipe that allows us to skip actually creating the
    # recipe in some cases (ValueResources use this a lot).
    #
    def cook_new(recipe_class, *recipe_args, &recipe_block)
      self.class.cook_new_recipe(recipe_class, *recipe_args, &recipe_block)
      add_recipe(recipe_class.new(self, *recipe_args, &recipe_block))
    end

    module ResourceType
      def cook_recipe(recipe)
      end

      def cook_new_recipe(recipe_class, *recipe_args, &recipe_block)
      end

      def cook_recipe(recipe)
      end

    end
  end

  #     - SetResource
  #     - ArrayResource
  #     - StructResource
  #     - RubyModule
  #       - StructResourceModule - Module that represents a full StructResource,
  #         with Attributes.
  #       - RecipeConstructorModule: Hash of resource constructors
  #     - RubyClass
  #   - Resources: Hash of open resources by canonical url
  #   - Recipe: general term for "the".
  #     - RecipeCollection
  #
  # - Resource: A reference to a real resource, with verbs to modify it and to
  #   create recipes for it.
  #   - ValueResource: Resources that look like native values.  Meant to be extended.
  #     - StructResource: A Resource with a list of known attributes (each of which is a Resource)
  #     - OpenStructResource: A Resource with a list of known attributes, with a Hash interface, which allows unknown attributes as well.
  #     - HashResource: A Resource on top of a Hash.
  #     - SetResource: A Resource on top of a Set.
  #     - ArrayResource: A Resource on top of an Array.
  #     - Symbol, Boolean, Path
  #   - ResourceClass: Resource classes.
  #   - Accessor:
  #     - StructAttributeAccessor:
  #     - HashValueAccessor:
  #     - SetItemAccessor:
  #     - ArrayElementAccessor:
  #   - ResourceClassCollection: a collection of resource types, with names (a Hash).
  #   - Recipe: A plan for changing a Resource.  Can be thought of as a
  #     transaction and `commit`ed.
  #     - ValueRecipe: A Ruby DSL that lets you treat the Resource like a noun, but
  #       which builds a Recipe instead of modifying the Resource.
  #       - StructRecipe: A Struct-compatible DSL that batches updates to an
  #         underlying hash value.
  #       - HashRecipe: A Hash-compatible DSL that batches updates to an underlying
  #         hash value.
  #       - ArrayRecipe: An Array-compatible DSL that batches updates to an array
  #       - SetRecipe: A Set-compatible DSL that batches updates to an array
  #       - ListRecipe: A linked-list compatible DSL that batches updates.
  #       - ProxyRecipe: A recipe that batches a set of calls to an object.
  #     - Action: A non-decomposable verb; will either execute or not.
  #       - RubyBlockAction: runs a ruby block.
  #       - ExecuteAction: executes a command.
  #     - RecipeDSL: sits atop a ResourceClassCollection and provides methods
  #       like `file '/x.txt' do ... end` that instantiate file '/x.txt', create
  #       a recipe from it and get ready to run the block against the recipe.
  #       - mode = :immediate: runs all recipes immediately (as they are defined).
  #       - mode = :delayed: defines all recipes but saves the blocks (executes
  #         them at commit).  Similar to what we have now, but somewhat less
  #         boneheaded (blocks become lazy).
  #       - mode = :delayed_commit: defines all recipes, runs the blocks, but
  #         does not commit until the very end.  This is the most like what we
  #         currently have.
  #       - mode = :parallel: runs all recipes in parallel (immediately as they
  #         are defined).
  #


    #
    # A Recipe is a *transaction* against a Resource.  While it is open, you
    # may make proposed changes to the Resource and the changes will not be
    # visible until `commit` is called (and will be thrown away if `dispose`
    # or `dry_run` are called instead).
    #
    module Recipe
      # commit(&block), dispose, dry_run

      #
      # Yields each actual update (as a Recipe) as it is processed
      #
      def commit
      end

      #
      # Resources are types, diffable, and convergable.
      #
      # A Resource MUST be:
      # - Rigorous: if the user requests a value that the Resource cannot perform, it
      #   must throw an exception.
      # - Conservative: if the user does not ask to make any changes, no changes are made.
      # - Transactional: if commit is not called, none of the changes the user
      #   specifies are made.
      # - Complete: any collection values on the resource represent the full attribute.
      #   If a directory resource has a `children` attribute, and updates it, any
      #   children not in the collection should be removed.
      #
      # A resource SHOULD be:
      # - Lazy: if the user never asks for a value, we never actually query the resource
      # - Surgical: if the user does not ask to change a value, it does not try to update
      #   that value.
      # - Threadsafe: if the user uses the resource's current value, and that value
      #   was changed after it was retrieved but before the update, the update fails.
      # - Atomic: at any point during or after `commit`, any user that can see one
      #   changed value can see all changed values.
      # - Failure Clean: if there is a failure, no changes are made.
      #
      # A resource MAY be:
      # - Convergent: able to converge part of a resource if passed `converge`.
      #
      #
      # Overriding
      # ==========
      # The simplest override with the least amount of complexity is thus:
      #
      # class MyFile < ResourceClass
      #   attribute :path
      #   attribute :mode, default { File.stat(path).mode }
      #
      #   def commit
      #     log.commit do
      #       if mode != File.stat(path).mode
      #         update "Modify #{path} mode from #{File.stat(path).mode} to #{mode}" do
      #           File.chmod(mode, path)
      #         end
      #       end
      #     end
      #   end
      # end
      #
end
